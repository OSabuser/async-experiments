# Futures in Rust

> Футура - некоторая операция, которая будет выполнена в будущем.  

Ассинхронность в Rust реализуется с помощью постоянного опроса - `poll` в котором у каждой задачи может быть 3 фазы:

1. `The poll phase` - футура опрашивается и выполняется (прогрессирует) до того момента, пока она может быть выполнена (либо щавершается, либо не может продолжать выполнение в данный момент, т.к. требуется возникновение некоторого события). Часть асинхронного рантайма, которая опрашивает футуры - `Executor`.
2. `The wait phase` - футура ожидает некоторого события. Источник событий - `Reactor`, пробуждает футуры в случае появления этого события.
3. `The wake phase` - после возникновения события, футура "пробуждается". `Executor` вносит футуру в список на выполнение, чтобы опять выполнить фазу `The poll phase`.

## Leaf футуры

Создаются рантаймами - `Scheduler`, представляют собой ресурс, например, сокет:

```rust
let mut stream = tokio::net::TcpStream::connect("127.0.0.1:8080");
```

Операции, выполняемые над этими ресурами, например, чтение из сокета, будут неблокирующими и возращают `Future`, которая зовётся `leaf` (т.к. это футура, выполнение которой мы ожидаем).  

## Non-leaf футуры

> Это футуры. которые мы, как пользователи рантайма, создаём самостоятельно, используя ключевое слово `async`, для того, чтобы создать задачу,  
которая может быть запущена `Executor`-ом.  

Основная масса асинхронных приложений состоит из таких футур. Они представляются собой вычисления, которые могут быть приостановлены в определённом моменте.  
Таким образом `non-leaf futures` представляют собой набор операций-вычислений. Часто, такие задачи будут `await` - ожидать выполнения  `leaf-futures` для того, чтобы завершить свою работу.  

```rust
let non_leaf = async {
    let mut stream = tokio::net::TcpStream::connect("127.0.0.1:8080").await.unwrap(); // (1)
    println!("Connected to {}", stream.peer_addr().unwrap());
    let result = stream.write(b"Hello world!").await; // (2)
    println!("Message sent!");
    //  Операции (1) и (2) - места, где поток выполнения будет приостановлен, передавая контроль рантайму и, в последствии, возвращая контроль обратно.
};
```

`Non-leaf` футуры не представляют собой `I/O` ресурс в отличии от `Leaf` футур. Когда `non-leaf` футура опрашивается `Executor`-ом,  
**она будет выполняться до тех пор, пока не попадёт на `leaf` футуру, которая вернёт статус `Pending` и передаст контроль `Scheduler`-у**.

## Модель async runtime

1. `Reactor` - ответственный за уведомление о событиях `I/O`
2. `Executor` - `Executor`
3. `Future` - задача, выполнение которой может приостанавливаться и возобновляться в определённом моменте
  
- `Executor` хранит список футур, которые нужно выполнить. Он поопробует выполнить футуру, выполняя поллинг (`The poll phase`)  
Футура при выполнении возвращает `Poll::Ready` (закончила выполнение) или `Poll::Pending`.  
(ещё не закончили выполнение и в данный момент продвинуться дальше не можем). После получение данных результатов (`Ready` или `Pending`), `Executor` может приступать к
поллингу следующей футуры (возврат контроля к `Executor` - `yield point`).  После поллинга, `Executor` создает объект `Waker` и передает его в футуру.
- `Reactor` хранит копию `Waker`-а, которую `Executor` связал с футурой во время её поллинга.  
`Reactor` следит за `I/O` событиями для этой футуры, используя `event-queue` (epoll, kqueue, ...)
- Когда `Reactor` получает уведомление, что произошло одно из событий, за которыми он следит, он находит связанный с данным событием `Waker`,  
и вызывает `Waker::wake`. Этот вызов, в свою очередь, информирует `Executor` о том, что футура готова к выполнению (прогрессированию) и можно осуществить процесс поллинга.  

```rust
async fn foo() {
    println!("Start!");
    let txt = io::read_to_string().await.unwrap(); // Возврат контроля планировщику
    println!("Done: {}", txt);
}
```

> `Executor` и `Reactor` обычно не связаны друг с другом напрямую

## Стандартная библиотека Rust

1. Обеспечивает общий интерфейс - трейт `Future`, представляющий собой операцию, которая будет выполнена в будущем
2. Предоставляет удобный способ создания задач (корутины без контекста-стека), которые могут быть приостановлены и возобновлены (`async` / `await`)
3. Определяет интерфейс для пробуждения приостановленной задачи с помощью типа `Waker`

```rust
let non_leaf = async {
    let mut stream = tokio::net::TcpStream::connect("127.0.0.1:8080").await.unwrap(); // (1)

    // Request a large dataset
    let result = stream.write(get_dataset_request).await.unwrap(); // (2)

    // Wait for the dataset
    let mut response = vec![];
    stream.read(&mut response).await.unwrap(); // (3)

    // Do some CPU-intensive analysic on the dataset
    let report = analyze(response); // (4)

    // Send the report back
    stream.write(report).await.unwrap(); // (5)
}
```

В точках `(1)`-`(5)` осуществляется передача управления `Executor`. Код, написанный между `yield-points` выполнится работает в том же потоке, что и `Executor`.  
Это означает что в то время, как `analize` обрабатывает результаты набора данных,  
`Executor` будет заниматься вычислениями, вместо того, что будет заниматься другими задачами - **ЭТО НЕХОРОШО!**

Пути исправления ситуации:

1. Можно создать новую `leaf-футуру` которая перенаправит нашу задачу в новый поток выполнения и сообщит, когда она будет выполнена. Мы можем `await` выполнение этой `leaf-футуры`
2. Рантайм может обладать супервизором, который следит за тем, как много времени потребляют различные задачи и перенаправляет `Executor` на другие потоки для выполнения других задач, несмотря на то, что задача `analyze` блокирует первоначальный поток выполнения.
3. Можно создать `Reactor` самостоятельно, совместимый с рантаймом

> Чаще всего используется `метод 1`. Не все рантаймы поддерживают `метод 2`.
