# Proof of concept

Предыдущий пример - [runtime_without_waker](../runtime/README.md) имеет существенный недостаток: тесная связь между `Executor` и `Reactor` через `Poll`.  
Естественное желание - передача контроля `планировщику ОС` в случае, когда в приложении нет задач для выполнения в текущий момент и возврат контроля,  
когда возникло определённое событие выполняется посредством блокировки на `Poll::poll` => и `Reactor` и `Executor` должны знать о `Poll`. 

[runtime_without_waker](old.png)

## Waker

> Для снижения взаимосвязи, необходим интерфейс предназначенный для сообщения `Executor` о том, что он должен пробудиться,
> когда возникло событие, позволяющее одной из футур прогрессировать.

[runtime_with_waker](new.png)

`Executor` планирует выполнение задач и передаёт `Waker` когда опрашивает футуру. В последствии `Waker` передается и хранится `Reactor`-ом. Когда `Reactor` получает уведомление о том,  
что произошло событие, он находит `Waker` связанный с этим событием-задачей и вызывает `Waker::wake`. Это позволяет:  

- Запускать несколько потоков ОС, каждый со своим `Executor`-ом и общим `Reactor`-ом
- Иметь несколько `Reactor`-ов, которые занимаются обработкой различных типов leaf-футур и пробуждают необходимый `Executor`, когда футура может прогрессировать