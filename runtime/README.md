# Runtimes, Wakers & Reactor-Executor pattern

## Runtimes

Необходимы для управления асихронными задачами.  
Примеры: `tokio`, `Embassy`..

Задачи рантайма:

- Планировка задач
- Выполнение задач
  
При использовании userland runtime(`tokio` и т.д.), не рекомендутся использовать функционал планировщика OS, например,  
`std::thread::sleep`,`std::net::TcpStream` и т.д. Эти вызовы заблокируют работу async-runtime. Даже потенциально блокирующие вызовы,  
такие как `Mutex` могут передать управление OS планировщику.

### Async-runtime должны использовать non-blocking версию стандартной библиотеки

1. Часть рантайма, которая следит за ожидаемыми задачами событиями и прослушивает уведомления от ОС (kqueue, epoll, ...), называется `Reactor`
2. Часть рантайма, которая планирует и опрашивает (polling) задачи - `Executor`

> `Reactor` собирает набор входящих событий и передаёт их по-одному обработчику (`Executor`). Представляет собой `Event Loop`.

Пример событий: переполнение счётчика таймера, прерывание, I/O события (`READABLE` на `TcpStream`).  

> `Executor` принимает решение о том, **какая** из задач получит процессорное время и **когда** они его получат.
> Также `Executor` долже вызывать `Future::poll` и обновлять состояния State Machine футур.  
